---
content_type: page
layout: instructor_insights
title: Instructor Insights
uid: 55d505b1-69f7-f01b-fee9-cba048f3cd8f
---

Course Overview
---------------

This page focuses on the course _6.046 Design and Analysis of Algorithms_ as taught by Professors Erik Demaine, Srini Devadas, and Nancy Lynch in Spring 2015.

This course is an intermediate class covering the design of computer algorithms and the analysis of sophisticated algorithms. Students learn how to analyze the asymptotic performance of algorithms, and gain familiarity with major algorithms and data structures. They also apply important algorithmic design paradigms and methods of analysis, in addition to synthesizing efficient algorithms in common engineering design situations. Course materials are designed to help students understand the difference between tractable and intractable problems and to become familiar with strategies to deal with intractability. Students attend lectures and recitation sessions, and complete 10 problem sets throughout the semester.

Curriculum Information
----------------------

### Prerequisites

*   [_6.006 Introduction to Algorithms_](/courses/6-006-introduction-to-algorithms-fall-2011/)
*   Either [_6.042J Mathematics for Computer Science_](/courses/6-042j-mathematics-for-computer-science-fall-2010/) or [_18.310 Principles of Discrete Applied Mathematics_](/courses/18-310-principles-of-discrete-applied-mathematics-fall-2013/)

### Requirements Satisfied

6.046 can be applied toward a [Bachelor of Science in Computer Science and Engineering](http://catalog.mit.edu/degree-charts/computer-science-engineering-course-6-3/).

### Offered

Every fall and spring semester

{{< anchor "insights" >}}{{< /anchor >}}

Meet the Educator
-----------------

![Man with glasses sits in front of geometric paper sculptures.]({{< resource_file 2bb373d5-5379-9f63-e629-ff8d265a988e >}})

Erik Demaine, Professor in the Department of Electrical Engineering & Computer Science

_In the following video, Erik Domaine discusses his role in the course, his interest in algorithms, and how teaching _6.046 Design and Analysis of Algorithms_ helps him understand algorithms at a deeper level._

*   [Meet the Educator: Erik Demaine]({{< baseurl >}}/resources/meet-the-educator)

{{< anchor "insights" >}}{{< /anchor >}}

Instructor Insights
-------------------

{{< quote "This is me living the dream, teaching the topic I love." "—Erik Demaine" >}}

_In the following videos, Professor Erik Demaine describes various aspects of how he teaches _6.046 Design and Analysis of Algorithms_._

*   [On Teaching Complex Content]({{< baseurl >}}/resources/on-teaching-complex-content)
*   [On the Challenge of Assessing Students’ Abilities to Apply Algorithms in New and Creative Ways]({{< baseurl >}}/resources/on-the-challenge-of-assessing-students-abilities)
*   [Engaging Learners]({{< baseurl >}}/resources/engaging-learners)
*   [Co-Teaching the Course]({{< baseurl >}}/resources/co-teaching-the-course)

{{< anchor "assessment" >}}{{< /anchor >}}

Assessment
----------

The students' grades were based on the following activities:

- 30% Problem sets
- 20% Quiz 1 (2 hours)
- 20% Quiz 2 (2 hours)
- 30% Final exam (3 hours)

### Instructor Insights on Assessment
Professor Erik Demaine shares his insights about assessment in his video, “[On the Challenge of Assessing Students’ Abilities to Apply Algorithms in New and Creative Ways]({{< baseurl >}}/resources/on-the-challenge-of-assessing-students-abilities).”

Student Information
-------------------

![Approximately 250 students take this course each time it is offered.]({{< resource_file c5001d6d-8d86-a796-91e1-1d462af4dee5 >}})

### Breakdown by Year

Mostly juniors and seniors

### Breakdown by Major

Mostly computer science majors

### Typical Student Background

Students tends to be interested in exploring algorithms at a more sophisticated level than what is typically offered in introductory level courses.

Course Outcomes
---------------

### Course Goals for Students

Students who complete this course will have demonstrated the ability to do the following:

*   Argue the correctness of algorithms using inductive proofs and loop invariants.
*   Analyze worst-case running times of algorithms using asymptotic analysis. Compare the asymptotic behaviors of functions obtained by elementary compositions of polynomials, exponentials, and logarithmic functions. Describe the relative merits of worst-, average-, and best-case analysis.
*   Analyze average-case running times of algorithms whose running time is probabilistic. Employ indicator random variables and linearity of expectation to perform the analyses. Recite analyses of algorithms that employ this method of analysis.
*   Explain the basic properties of randomized algorithms and methods for analyzing them. Recite algorithms that employ randomization. Explain the difference between a randomized algorithm and an algorithm with probabilistic inputs.
*   Describe the divide-and conquer paradigm and explain when an algorithm design situation calls for it. Recite algorithms that employ this paradigm. Synthesize divide-and-conquer algorithms. Derive and solve recurrences describing the performance of divide-and-conquer algorithms.
*   Describe the dynamic-programming paradigm and explain when an algorithmic design situation calls for it. Recite algorithms that employ this paradigm. Synthesize dynamic programming algorithms, and analyze them.
*   Describe the greedy paradigm and explain when an algorithm design situation calls for it. Recite algorithms that employ this paradigm. Synthesize greedy algorithms, and analyze them.
*   Explain the major graph algorithms and their analyses. Employ graphs to model engineering problems, when appropriate. Synthesize new graph algorithms and algorithms that employ graph computations as key components, and analyze them.
*   Describe a linear program and cite problems that can be solved using linear programming. Reduce problems to linear programming formulations. Understand the complexity of various linear programming approaches.
*   Explain basic complexity classes such as P, NP, and NP-complete, and be able to use analysis and reduction techniques to show membership or non-membership of a problem in these classes.
*   Describe approaches to speeding up algorithms by making use of distributed and/or parallel computation.
*   Explain the concept and basic examples of basing cryptographic security on hard computational problems.
*   Understand and explain approaches to dealing with problems that are NP-complete such as the design of heuristic, approximation, or fixed-parameter algorithms.